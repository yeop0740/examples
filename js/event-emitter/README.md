# event-emitter 사용

## 테스트 방법

test 를 실행하기 위한 스크립트는 `package.json` 에 명시되어 있습니다.

첫 번째 쉘에서 서버를 실행합니다.
```shell
npm run dev
```

두 번째 쉘에서 테스트를 실행합니다.
```shell
npm run test
```

## 실험의 목적

event emitter 는 이벤트가 발생하면 핸들러를 동기적으로 호출한다고 보았습니다.
단순히 핸들러를 호출하는 과정이 동기적이라는 의미인지, 혹은 호출한 핸들러 내부의 작업까지 동기적으로 수행한다는 의미인지 명확히 해석할 수 없어서(영어 실력의 부족으로 인한) 동기적 호출의 범위를 확인하는 것이 이 실험의 목적이자 목표입니다.

싱글 스레드로 동작하는 이벤트 루프(개인적으론 메인 스레드의 용어로 잘 와닿는 것 같습니다)에서 동기적으로 실행되고, 블로킹이 발생한다면, 트래픽의 증가에 악영향을 줄 수 있기에 event emitter 의 사용으로 인한 이벤트 루프에 주는 영향을 확인하는 실험을 계획했습니다.

## server.ts

**/event**
POST_CREATED 이벤트를 event emitter 에 발행
event emitter 가 해당 이벤트를 소비하는 핸들러 호출
핸들러에서 1초 동안 실행되는 쿼리 호출

## event.test.ts

/event 라우터에 거의 동시에 6 개 요청 발생

[예상] 만약 이벤트 핸들러 내 동작이 동기적으로 실행된다면, 모든 요청이 응답을 받는데 6초 걸려야 합니다.
[결과] 모든 응답을 받는데 1초 미만 소요됩니다. 마지막에 종료된 쿼리의 종료 시간과 처음 종료한 쿼리의 종료 시간의 차이는 수십 ms 차이가 나는 것으로 확인했습니다.

[결론] event emitter 가 호출한 핸들러 내부의 작업은 비동기적으로 수행된다는 것을 확인할 수 있었습니다.

## 추가적으로 생각해 볼 것

대게는 실행되는데 시간이 걸리는 작업을 이벤트를 이용하여 분리할 것으로 생각됩니다.
이때 단순히 웹 서버의 프로세스에서 이를 담당하도록 하면 해당 프로세스에 부하를 줄 것으로 보입니다.
prisma 의 경우 쿼리가 prisma 의 connection pool 의 대기 큐에 들어간 순간 부터 커넥션을 획득하여 실제 수행하는데까지 걸리는 시간을 제한(타임아웃)하고 있기 때문에 수행되어야 하는 작업이 유실됩니다(단순 read 작업이라면 문제되지 않지만, 변경을 해야하는 작업이라면 데이터의 유실로 이어집니다).
따라서 타임아웃에 대한 유실을 방지하기 위해 큐를 이용하여 유실되는 요청을 최소화 할 수 있을 것이라고 생각되었습니다.
핸들러에서 수행하는 작업의 평균 시간(혹은 타임아웃 시간)이 큐에 전송할 때 소요되는 평균 시간보다 높다면 큐를 도입하는 것이 서버 프로세스의 안정성을 높히는 방법이 된다는 것을 생각해볼 수 있었습니다.

하나의 요청에서 백그라운드로 특정 작업을 수행하고자 event emitter 의 사용법과 확인할 것을 테스트

- request 기준으로 백그라운드에서 동작하는지(setInternal / promise 생성 필요 여부 확인)
- event listener 에서 발생한 예외 처리 확인

## TODO

- [ ] connection limit 체크
- [ ] event 가 소비되지 않고 쌓이는 경우 프로세스에 미치는 영향
